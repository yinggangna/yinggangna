<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    锁 |  WangYingGangBlogs
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="WangYingGangBlogs" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Java/锁/锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  锁
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/05/05/Java/%E9%94%81/%E9%94%81/" class="article-date">
  <time datetime="2021-05-05T12:18:57.000Z" itemprop="datePublished">2021-05-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">12.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">48 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="从-synchronized-到-CAS-和-AQS"><a href="#从-synchronized-到-CAS-和-AQS" class="headerlink" title="从 synchronized 到 CAS 和 AQS"></a>从 synchronized 到 CAS 和 AQS</h1><p>Java 中的并发锁大致分为隐式锁和显式锁两种。</p>
<p>隐式锁就是我们最常使用的 synchronized 关键字，</p>
<p>显式锁主要包含两个接口：Lock 和 ReadWriteLock，主要实现类分别为 ReentrantLock 和 ReentrantReadWriteLock，这两个类都是基于 AQS(AbstractQueuedSynchronizer) 实现的。</p>
<p>还有的地方将 CAS 也称为一种锁，在包括 AQS 在内的很多<strong>并发相关类</strong>中，CAS 都扮演了很重要的角色。</p>
<h2 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h2><p>如果一个线程已经获取到了一个锁，那么它可以访问被这个锁锁住的所有代码块。</p>
<p>不可重入锁与之相反。</p>
<h2 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h2><p>Synchronized 是一种独占锁。在修饰静态方法时，锁的是类对象，如 Object.class。修饰非静态方法时，锁的是对象，即 this。</p>
<p>修饰方法块时，锁的是括号里的对象。 每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性。</p>
<h2 id="类锁与对象锁"><a href="#类锁与对象锁" class="headerlink" title="类锁与对象锁"></a>类锁与对象锁</h2><p>synchronized 修饰静态方法时，锁的是类对象,如 Object.class。修饰非静态方法时，锁的是对象，即 this。 多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的。</p>
<p>synchronized 锁住的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。</p>
<p>此外，需要说明的，synchronized方法不能防止非synchronized方法被同时执行，所以，一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>synchronized 是基于 Java 对象头和 Monitor 机制来实现的。</p>
<h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>一个对象在内存中包含三部分：对象头，实例数据和对齐填充。其中 Java 对象头包含两部分：</p>
<ul>
<li>Class Metadata Address （类型指针）。存储类的元数据的指针。虚拟机通过这个指针找到它是哪个类的实例。</li>
<li>Mark Word（标记字段）。存出一些对象自身运行时的数据。包括哈希码，GC 分代年龄，锁状态标志等。</li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。 monitor 对象由 C++ 实现。其中有三个关键字段：</p>
<ul>
<li>_owner 记录当前持有锁的线程</li>
<li>_EntryList 是一个队列，记录所有阻塞等待锁的线程</li>
<li>_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程。</li>
</ul>
<p>Monitor的操作机制如下：</p>
<ol>
<li>多个线程竞争锁时，会先进入 EntryList 队列。竞争成功的线程被标记为 Owner。其他线程继续在此队列中阻塞等待。</li>
<li>如果 Owner 线程调用 wait() 方法，则其释放对象锁并进入 WaitSet 中等待被唤醒。Owner 被置空，EntryList 中的线程再次竞争锁。</li>
<li>如果 Owner 线程执行完了，便会释放锁，Owner 被置空，EntryList 中的线程再次竞争锁。</li>
</ol>
<h3 id="JVM-对-synchronized-的处理"><a href="#JVM-对-synchronized-的处理" class="headerlink" title="JVM 对 synchronized 的处理"></a>JVM 对 synchronized 的处理</h3><p>上面了解了 monitor 的机制，那虚拟机是如何将 synchronized 和 monitor 关联起来的呢？分两种情况：</p>
<ul>
<li>如果同步的是代码块，编译时会直接在同步代码块前加上 monitorenter 指令，代码块后加上 monitorexit 指令。这称为显示同步。</li>
<li>如果同步的是方法，虚拟机会为方法设置 ACC_SYNCHRONIZED 标志。调用的时候 JVM 根据这个标志判断是否是同步方法。</li>
</ul>
<h2 id="JVM-对-synchronized-的优化"><a href="#JVM-对-synchronized-的优化" class="headerlink" title="JVM 对 synchronized 的优化"></a>JVM 对 synchronized 的优化</h2><p>synchronized 是重量级锁，由于消耗太大，虚拟机对其做了一些优化。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>在许多应用中，锁定状态只会持续很短的时间，为了这么一点时间去挂起恢复线程，不值得。我们可以让等待线程执行一定次数的循环，在循环中去获取锁。这项技术称为自旋锁，它可以节省系统切换线程的消耗，但仍然要占用处理器。在 JDK1.4.2 中，自选的次数可以通过参数来控制。 JDK 1.6又引入了自适应的自旋锁，不再通过次数来限制，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>虚拟机在运行时，如果发现一段被锁住的代码中不可能存在共享数据，就会将这个锁清除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>当虚拟机检测到有一串零碎的操作都对同一个对象加锁时，会把锁扩展到整个操作序列外部。如 StringBuffer 的 append 操作。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>对绝大部分的锁来说，在整个同步周期内都不存在竞争。如果没有竞争，轻量级锁可以使用 CAS 操作避免使用互斥量的开销。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="操作模型"><a href="#操作模型" class="headerlink" title="操作模型"></a>操作模型</h2><p>CAS 是 compare and swap 的简写，即比较并交换。它是指一种操作机制，而不是某个具体的类或方法。在 Java 平台上对这种操作进行了包装。在 Unsafe 类中，调用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>它需要三个参数，分别是内存位置 V，旧的预期值 A 和新的值 B。操作时，先从内存位置读取到值，然后和预期值A比较。如果相等，则将此内存位置的值改为新值 B，返回 true。如果不相等，说明和其他线程冲突了，则不做任何改变，返回 false。</p>
<p>这种机制在不阻塞其他线程的情况下避免了并发冲突，比独占锁的性能高很多。 CAS 在 Java 的原子类和并发包中有大量使用。</p>
<h2 id="重试机制（循环-CAS）"><a href="#重试机制（循环-CAS）" class="headerlink" title="重试机制（循环 CAS）"></a>重试机制（循环 CAS）</h2><p><strong>有很多文章说，CAS 操作失败后会一直重试直到成功，这种说法很不严谨。</strong></p>
<p>第一，CAS 本身并未实现失败后的处理机制，它只负责返回成功或失败的布尔值，后续由调用者自行处理。只不过我们最常用的处理方式是重试而已。</p>
<p>第二，这句话很容易理解错，被理解成重新比较并交换。实际上失败的时候，原值已经被修改，如果不更改期望值，再怎么比较都会失败。而新值同样需要修改。</p>
<p>所以正确的方法是，使用一个死循环进行 CAS 操作，成功了就结束循环返回，失败了就重新从内存读取值和计算新值，再调用 CAS。看下 AtomicInteger 的源码就什么都懂了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet () &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>CAS 主要分三步，读取-比较-修改。其中比较是在检测是否有冲突，如果检测到没有冲突后，其他线程还能修改这个值，那么 CAS 还是无法保证正确性。所以最关键的是要保证比较-修改这两步操作的原子性。</p>
<p>CAS 底层是靠调用 CPU 指令集的 cmpxchg 完成的，它是 x86 和 Intel 架构中的 compare and exchange 指令。在多核的情况下，这个指令也不能保证原子性，需要在前面加上 lock 指令。lock 指令可以保证一个 CPU 核心在操作期间独占一片内存区域。那么 这又是如何实现的呢？</p>
<p>在处理器中，一般有两种方式来实现上述效果：总线锁和缓存锁。在多核处理器的结构中，CPU 核心并不能直接访问内存，而是统一通过一条总线访问。总线锁就是锁住这条总线，使其他核心无法访问内存。这种方式代价太大了，会导致其他核心停止工作。而缓存锁并不锁定总线，只是锁定某部分内存区域。当一个 CPU 核心将内存区域的数据读取到自己的缓存区后，它会锁定缓存对应的内存区域。锁住期间，其他核心无法操作这块内存区域。</p>
<p>CAS 就是通过这种方式实现比较和交换操作的原子性的。<strong>值得注意的是， CAS 只是保证了操作的原子性，并不保证变量的可见性，因此变量需要加上 volatile 关键字。</strong></p>
<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>上面提到，CAS 保证了比较和交换的原子性。但是从读取到开始比较这段期间，其他核心仍然是可以修改这个值的。如果核心将 A 修改为 B，CAS 可以判断出来。但是如果核心将 A 修改为 B 再修改回 A。那么 CAS 会认为这个值并没有被改变，从而继续操作。这是和实际情况不符的。解决方案是加一个版本号。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 全称 AbstractQueuedSynchronizer。AQS 中有两个重要的成员：</p>
<ul>
<li>成员变量 state。用于表示锁现在的状态，用 volatile 修饰，保证内存一致性。</li>
<li>同时所用对 state 的操作都是使用 CAS 进行的。state 为0表示没有任何线程持有这个锁，线程持有该锁后将 state 加1，释放时减1。多次持有释放则多次加减。</li>
<li>还有一个双向链表，链表除了头结点外，每一个节点都记录了线程的信息，代表一个等待线程。这是一个 FIFO 的链表。</li>
</ul>
<p>下面以 ReentrantLock 非公平锁的代码看看 AQS 的原理。</p>
<h2 id="请求锁"><a href="#请求锁" class="headerlink" title="请求锁"></a>请求锁</h2><p>请求锁时有三种可能：</p>
<ol>
<li>如果没有线程持有锁，则请求成功，当前线程直接获取到锁。</li>
<li>如果当前线程已经持有锁，则使用 CAS 将 state 值加1，表示自己再次申请了锁，释放锁时减1。这就是可重入性的实现。</li>
<li>如果由其他线程持有锁，那么将自己添加进等待队列。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))   </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread()); //没有线程持有锁时，直接获取锁，对应情况1</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; //在此方法中会判断当前持有线程是否等于自己，对应情况2</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //将自己加入队列中，对应情况3</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="创建-Node-节点并加入链表"><a href="#创建-Node-节点并加入链表" class="headerlink" title="创建 Node 节点并加入链表"></a>创建 Node 节点并加入链表</h2><p>如果没竞争到锁，这时候就要进入等待队列。队列是默认有一个 head 节点的，并且不包含线程信息。上面情况3中，addWaiter 会创建一个 Node，并添加到链表的末尾，Node 中持有当前线程的引用。同时还有一个成员变量 waitStatus，表示线程的等待状态，初始值为0。我们还需要关注两个值：</p>
<ul>
<li>CANCELLED，值为1，表示取消状态，就是说我不要这个锁了，请你把我移出去。</li>
<li>SINGAL，值为-1，表示下一个节点正在挂起等待，注意是下一个节点，不是当前节点。</li>
</ul>
<p>同时，加到链表末尾的操作使用了 CAS+死循环的模式，很有代表性，拿出来看一看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node node = new Node(mode);</span><br><span class="line">for (;;) &#123;</span><br><span class="line">    Node oldTail = tail;</span><br><span class="line">    if (oldTail != null) &#123;</span><br><span class="line">        U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">        if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">            oldTail.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        initializeSyncQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到，在死循环里调用了 CAS 的方法。如果多个线程同时调用该方法，那么每次循环都只有一个线程执行成功，其他线程进入下一次循环，重新调用。N个线程就会循环N次。这样就在无锁的模式下实现了并发模型。</p>
<h2 id="挂起等待"><a href="#挂起等待" class="headerlink" title="挂起等待"></a>挂起等待</h2><ul>
<li>如果此节点的上一个节点是头部节点，则再次尝试获取锁，获取到了就移除并返回。获取不到就进入下一步；</li>
<li>判断前一个节点的 waitStatus，如果是 SINGAL，则返回 true，并调用 LockSupport.park() 将线程挂起；</li>
<li>如果是 CANCELLED，则将前一个节点移除；</li>
<li>如果是其他值，则将前一个节点的 waitStatus 标记为 SINGAL，进入下一次循环。</li>
</ul>
<p>可以看到，一个线程最多有两次机会，还竞争不到就去挂起等待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        throw t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><ul>
<li>调用 tryRelease，此方法由子类实现。实现非常简单，如果当前线程是持有锁的线程，就将 state 减1。减完后如果 state 大于0，表示当前线程仍然持有锁，返回 false。如果等于0，表示已经没有线程持有锁，返回 true，进入下一步；</li>
<li>如果头部节点的 waitStatus 不等于0，则调用LockSupport.unpark()唤醒其下一个节点。头部节点的下一个节点就是等待队列中的第一个线程，这反映了 AQS 先进先出的特点。另外，即使是非公平锁，进入队列之后，还是得按顺序来。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123; //将 state 减1</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        node.compareAndSetWaitStatus(ws, 0);</span><br><span class="line">        </span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123; </span><br><span class="line">        s = null;</span><br><span class="line">        for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span><br><span class="line">            if (p.waitStatus &lt;= 0)</span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null) //唤醒第一个等待的线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="公平锁如何实现"><a href="#公平锁如何实现" class="headerlink" title="公平锁如何实现"></a>公平锁如何实现</h2><p>上面分析的是非公平锁，那公平锁呢？很简单，在竞争锁之前判断一下等待队列中有没有线程在等待就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp; //判断等待队列是否有节点</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>





<h2 id="AQS用到了设计模式"><a href="#AQS用到了设计模式" class="headerlink" title="AQS用到了设计模式"></a>AQS用到了设计模式</h2><h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>AQS这个抽象类把模板方法设计模式运用地炉火纯青，它里面定义了一系列的模板方法，比如下面这些：</p>
<p>获取锁、释放锁的这些方法基本上都穿插在ReentrantLock、ReentrantReadWriteLock、CountDownLatch的源码解析中了，现在看他们是不是舒服多了，如果一开始就看这些源码，难免会很晕。</p>
<p>这几个方法为什么不直接定义成抽象方法呢？</p>
<p>因为子类只要实现这几个方法中的一部分就可以实现一个同步器了，所以不需要定义成抽象方法。</p>
<p>定义：封装一个模板结构，将具体内容延迟到子类去实现</p>
<p>将多个类共有的方法和功能抽取出来，封装到抽象类，对于这些公有方法（模板方法）使用final修饰，需要通过子类扩张的定义成抽象（abstract）方法，有子类实现其自有特性。</p>
<p>JDK AQS 抽象队列同步器就是一个构建锁和同步器的模板，使用它可以构建ReentrantLock（独占型），CountDownLacth（共享型），Semaphore（共享型）等同步组件。</p>
<p>AQS定义的可重写的方法：</p>
<ul>
<li><strong>protected boolean isHeldExclusively() ： 是否在独占模式下被线程占用。只有用到condition才需要去实现它</strong></li>
<li><strong>protected boolean tryAcquire(int arg) : 独占方式。尝试获取资源，成功则返回true，失败则返回false</strong></li>
<li><strong>protected boolean tryRelease(int arg) ：独占方式。尝试释放资源，成功则返回true，失败则返回false</strong></li>
<li><strong>protected int tryAcquireShared(int arg) ：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</strong></li>
<li><strong>protected boolean tryReleaseShared(int arg) ：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false</strong></li>
</ul>
<p>如果我们需要实现一个<strong>自定义的同步器</strong>，就只需要继承<strong>AQS</strong>，然后根据需求去重写响应的方法，</p>
<p>比如要实现<strong>独占锁</strong>，就实现tryAcquire()，tryRelease()方法，ReentrantLock就是这样做的，</p>
<p>同样，要实现<strong>共享锁</strong>，就需要实现tryAcquireShared()，tryReleaseShared()方法，比如Semaphore，CountDownLatch，</p>
<p>最后在要实现的组件中调用AQS中定义的模板方法。</p>
<p>在ReentrantLock中，我们只需要实现对state进行简单的获取释放操作，至于获取资源失败，构建节点加入等待队列，线程阻塞唤醒一系列逻辑在AQS的模板方法中已经帮我们实现了。</p>
<p><strong>AQS为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列&#x2F;出队列，阻塞&#x2F;唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可</strong></p>
<p><strong>为什么上面定义的四个方法不是模板方法模式要求的抽象方法，让子类实现呢？</strong></p>
<p>这是因为在独占锁中不需要实现tryAcquireShared()，tryReleaseShared()方法，而在共享锁中，也不需要tryAcquire()，tryRelease()方法，它们各自有自己的实现，如果定义成抽象方法，就必须实现所有，所以使用重写。</p>
<p>下面实现一个自定义的同步器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">//是否处于占用状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取同步资源</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里没有考虑可重入锁</span></span><br><span class="line">            <span class="comment">/*else if (Thread.currentThread() == getExclusiveOwnerThread()) &#123;</span></span><br><span class="line"><span class="comment">                int nextc = c + acquires;</span></span><br><span class="line"><span class="comment">                if (nextc &lt; 0) // overflow</span></span><br><span class="line"><span class="comment">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span></span><br><span class="line"><span class="comment">                setState(nextc);</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 释放同步资源</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ReentrantLock源码和上面自定义的同步器很相似，<br>测试下该同步器，i++在多线程下执行情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSelfSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SelfSynchronizer</span> <span class="variable">selfSynchronizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelfSynchronizer</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>, <span class="number">50</span>, <span class="number">1</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">ec</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">20</span> ; j++) &#123;</span><br><span class="line">            ec.submit(<span class="keyword">new</span> <span class="title class_">TaskSync</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a的值：&quot;</span>+ a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b的值&quot;</span> + b);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        ec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskSync</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            	<span class="comment">//使用同步器加锁</span></span><br><span class="line">                selfSynchronizer.lock();</span><br><span class="line">                b++;</span><br><span class="line">                selfSynchronizer.unLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启两个线程池，对int型变量自增10000次，如果不加同步器，最后值小于200000，使用了自定义同步器则最后值正常等于200000，这是因为每次自增操作加锁</p>
<h2 id="添加到queue队尾步骤"><a href="#添加到queue队尾步骤" class="headerlink" title="添加到queue队尾步骤"></a>添加到queue队尾步骤</h2><p> 将一个节点node添加到sync queue的末尾需要三步：</p>
<p><img src="/%E9%94%81/1415006-20200107160316392-893797227.png" alt="img"></p>
<p> 设置node的前驱节点为当前的尾节点：node.prev &#x3D; t</p>
<p>修改tail属性，使它指向当前节点 </p>
<p>修改原来的尾节点，使它的next指向当前节点尾分叉。</p>
<p>需要注意，这里的三步并不是一个原子操作，第一步很容易成功；而第二步由于是一个CAS操作，在并发条件下有可能失败，第三步只有在第二步成功的条件下才执行。这里的CAS保证了同一时刻只有一个节点能成为尾节点，其他节点将失败，失败后将回到for循环中继续重试所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整地完成这三步，而其他线程只能完成第一步，于是就出现了尾分叉：</p>
<p><img src="/%E9%94%81/1415006-20200107160457634-2047001299.png" alt="img"></p>
<p> 这 里第三步是在第二步执行成功后才执行的，这就意味着，有可能即使我们已经完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点的next值可能还 是null(因为还没有来的及执行第三步)，++++++++++++</p>
<p>另一方面，当我们完成了第二步之后，第一步一定是完成了的，所以如果我们从尾节点开始向前遍历，已经可以遍历到所有的节点。</p>
<p>这也就是为什么我们在AQS相关的源码中 (比如:unparkSuccessor(Node node) 中的：</p>
<p> 1 for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)) </p>
<p>通常是从尾节点开始逆向遍历链表——因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。</p>
<p>至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终，所有节点都会通过自旋不断的尝试入队，直到成功为止。</p>
<h1 id="可重入读写锁-ReentrantReadWriteLock"><a href="#可重入读写锁-ReentrantReadWriteLock" class="headerlink" title="可重入读写锁 ReentrantReadWriteLock"></a>可重入读写锁 ReentrantReadWriteLock</h1><h2 id="读写锁机制"><a href="#读写锁机制" class="headerlink" title="读写锁机制"></a>读写锁机制</h2><p>理解 ReentrantLock 和 AQS 之后，再来理解读写锁就很简单了。读写锁有一个读锁和一个写锁，分别对应读操作和锁操作。锁的特性如下：</p>
<ul>
<li>只有一个线程可以获取到写锁。在获取写锁时，只有没有任何线程持有任何锁才能获取成功；</li>
<li>如果有线程正持有写锁，其他任何线程都获取不到任何锁；</li>
<li>没有线程持有写锁时，可以有多个线程获取到读锁。</li>
</ul>
<p>上面锁的特点保证了可以并发读取，这大大提高了效率，在实际开发中非常有用。那么在具体是如何实现的呢？</p>
<h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>读写锁虽然有两个锁，但实际上只有一个等待队列。</p>
<ul>
<li>获取写锁时，要保证没有任何线程持有锁；</li>
<li>写锁释放后，会唤醒队列第一个线程，可能是读锁和写锁；</li>
<li>获取读锁时，先判断写锁有没有被持有，没有就可以获取成功；</li>
<li>获取读锁成功后，会将队列中等待读锁的线程挨个唤醒，知道遇到等待写锁的线程位置；</li>
<li>释放读锁时，要检查读锁数，如果为0，则唤醒队列中的下一个线程，否则不进行操作。</li>
</ul>
<h1 id="可重入锁与不可重入锁"><a href="#可重入锁与不可重入锁" class="headerlink" title="可重入锁与不可重入锁"></a>可重入锁与不可重入锁</h1><h1 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁 ReentrantLock"></a>可重入锁 ReentrantLock</h1><p>ReentrantLock 使用代码实现了和 synchronized 一样的语义，包括可重入，保证内存可见性和解决竞态条件问题等。相比 synchronized，它还有如下好处：</p>
<ul>
<li>支持以非阻塞方式获取锁</li>
<li>可以响应中断</li>
<li>可以限时</li>
<li>支持了公平锁和非公平锁</li>
</ul>
<p>基本用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    private volatile int count;</span><br><span class="line"></span><br><span class="line">    public void incr() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 内部有两个内部类，分别是 FairSync 和 NoFairSync，对应公平锁和非公平锁。他们都继承自 Sync。Sync 又继承自AQS。</p>
<ul>
<li><p>可重入锁：</p>
<p>可重入 <strong>就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</strong></p>
<p>防止在同一线程中多次获取锁而导致死锁发生。</p>
<p>synchronized 和 ReentrantLock都是可重入锁</p>
</li>
<li><p>不可重入锁</p>
</li>
</ul>
<p>不可重入锁，举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count</span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">4</span>         lock.lock();</span><br><span class="line"> <span class="number">5</span>         doAdd();</span><br><span class="line"> <span class="number">6</span>         lock.unlock();</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAdd</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">9</span>         lock.lock();</span><br><span class="line"><span class="number">10</span>         <span class="comment">//do something</span></span><br><span class="line"><span class="number">11</span>         lock.unlock();</span><br><span class="line"><span class="number">12</span>     &#125;</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当调用print()方法时，获得了锁，这时就无法再调用doAdd()方法，这时必须先释放锁才能调用，所以称这种锁为不可重入锁，也叫自旋锁。</p>
<h2 id="ReentrantLock可重入锁的例子"><a href="#ReentrantLock可重入锁的例子" class="headerlink" title="ReentrantLock可重入锁的例子"></a>ReentrantLock可重入锁的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">//锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//进入递归第一件事：加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;--------lock()执行后，当前线程持有此锁的次数：&#123;&#125; 是否有线程持有:&#123;&#125;&quot;</span>,lock.getHoldCount(),lock.isLocked());</span><br><span class="line">            log.info(<span class="string">&quot;--------递归&#123;&#125;次--------&quot;</span>,n);</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.doSomething(++n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;--------unlock()执行后，当前线程持有此锁的次数：&#123;&#125; 是否有线程持有:&#123;&#125;&quot;</span>,lock.getHoldCount(),lock.isLocked());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReentrantLockDemo reentrantLockDemo=<span class="keyword">new</span> <span class="title class_">ReentrantLockDemo</span>();</span><br><span class="line">        reentrantLockDemo.doSomething(<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;执行完doSomething方法 是否还持有锁：&#123;&#125;&quot;</span>,lock.isLocked());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lock.getHoldCount()    当前线程持有此锁的次数，如果当前线程未持有此锁，则为零</p>
</blockquote>
<blockquote>
<p>lock.isLocked()  查询此锁是否由任何线程持有。</p>
</blockquote>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- --------lock()执行后，当前线程持有此锁的次数：1 是否有线程持有:true</span><br><span class="line">- --------递归1次--------</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：2 是否有线程持有:true</span><br><span class="line">- --------递归2次--------</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：3 是否有线程持有:true</span><br><span class="line">- --------递归3次--------</span><br><span class="line">- --------unlock()执行后，当前线程持有此锁的次数：2 是否有线程持有:true</span><br><span class="line">- --------unlock()执行后，当前线程持有此锁的次数：1 是否有线程持有:true</span><br><span class="line">- --------unlock()执行后，当前线程持有此锁的次数：0 是否有线程持有:false</span><br><span class="line">- 执行完doSomething方法 是否还持有锁：false</span><br></pre></td></tr></table></figure>

<h6 id="从上面可以看出ReentrantLock是可重入锁，"><a href="#从上面可以看出ReentrantLock是可重入锁，" class="headerlink" title="从上面可以看出ReentrantLock是可重入锁，"></a>从上面可以看出ReentrantLock是可重入锁，</h6><h6 id="那么他是如何实现的了，我们看下源码就知道了"><a href="#那么他是如何实现的了，我们看下源码就知道了" class="headerlink" title="那么他是如何实现的了，我们看下源码就知道了"></a>那么他是如何实现的了，我们看下源码就知道了</h6><h2 id="ReentrantLock源码"><a href="#ReentrantLock源码" class="headerlink" title="ReentrantLock源码"></a>ReentrantLock源码</h2><h3 id="ReentrantLock的加锁流程是："><a href="#ReentrantLock的加锁流程是：" class="headerlink" title="ReentrantLock的加锁流程是："></a>ReentrantLock的加锁流程是：</h3><p>1，先判断是否有线程持有锁，没有加锁进行加锁<br>2、如果加锁成功，则设置持有锁的线程是当前线程<br>3、如果有线程持有了锁，则再去判断，是否是当前线程持有了锁<br>4、如果是当前线程持有锁，则加锁数量（state）+1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//先判断，c（state）是否等于0，如果等于0，说明没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//通过cas方法把state的值0替换成1，替换成功说明加锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">//如果加锁成功，设置持有锁的线程是当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//判断当前持有锁的线程是否是当前线程</span></span><br><span class="line">            <span class="comment">//如果是当前线程，则state值加acquires，代表了当前线程加锁了多少次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReentrantLock的加锁流程是：-1"><a href="#ReentrantLock的加锁流程是：-1" class="headerlink" title="ReentrantLock的加锁流程是："></a>ReentrantLock的加锁流程是：</h3><p>看ReentrantLock的解锁代码我们知道，每次释放锁的时候都对state减1，<br>当c值等于0的时候，说明锁重入次数也为0了，<br>最终设置当前持有锁的线程为null,state也设置为0，锁就释放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 释放锁</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;<span class="comment">//state-1 减加锁次数</span></span><br><span class="line">            <span class="comment">//如果持有锁的线程，不是当前线程，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果c==0了说明当前线程，已经要释放锁了</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);<span class="comment">//设置当前持有锁的线程为null</span></span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);<span class="comment">//设置c的值</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>看ReentrantLock的源码我们知道，它是加锁成功了，记录了当前持有锁的线程，并通过一个int类型的数字，来记录了加锁次数。</p>
<h2 id="redis-SET方式实现可重入锁的问题"><a href="#redis-SET方式实现可重入锁的问题" class="headerlink" title="redis SET方式实现可重入锁的问题"></a>redis SET方式实现可重入锁的问题</h2><h4 id="那么redis要怎么实现可重入的操作了？"><a href="#那么redis要怎么实现可重入的操作了？" class="headerlink" title="那么redis要怎么实现可重入的操作了？"></a>那么redis要怎么实现可重入的操作了？</h4><p>我们知道ReentrantLock的实现原理了，那么redis只要下面两个问题解决，就能实现重入锁了：<br>1、怎么保存当前持有的线程<br>2、加锁次数（重入了多少次），怎么记录维护</p>
<h5 id="1、第一个问题：怎么保存当前持有的线程"><a href="#1、第一个问题：怎么保存当前持有的线程" class="headerlink" title="1、第一个问题：怎么保存当前持有的线程"></a>1、第一个问题：怎么保存当前持有的线程</h5><p>1.valus值我们可以保存当前线程的id来解决。</p>
<p>\2. 但是集群环境下我们线程id可能是重复了那怎么解决？<br>项目在启动的生成一个全局进程id，使用进程id+线程id 那就是唯一的了</p>
<h5 id="2、第二个问题：加锁次数（重入了多少次），怎么记录维护"><a href="#2、第二个问题：加锁次数（重入了多少次），怎么记录维护" class="headerlink" title="2、第二个问题：加锁次数（重入了多少次），怎么记录维护"></a>2、第二个问题：加锁次数（重入了多少次），怎么记录维护</h5><ol>
<li>他能记录下来加锁次数吗？<br>如果valus值存的格式是：系进程id+线程id+加锁次数，那可以实现</li>
<li>存没问题了，但是重入次数要怎么维护了， 它肯定要保证原子性的，能解决吗？<br>好像用java代码或者lua脚本都没法解决，因为都是实现都需要两步来维护这个重入次数的</li>
</ol>
<ul>
<li>第一步：先获取到valus值，把取到加锁次数+1</li>
<li>第二部：把新的值再设置进去</li>
<li>在执行第二步操作之前，如果这个key失效了（设置持有锁超时了），如果还能再设置进去，就会有并发问题了</li>
</ul>
<h4 id="我们已经知道SET是不支持重入锁的，但我们需要重入锁，怎么办呢？"><a href="#我们已经知道SET是不支持重入锁的，但我们需要重入锁，怎么办呢？" class="headerlink" title="我们已经知道SET是不支持重入锁的，但我们需要重入锁，怎么办呢？"></a>我们已经知道SET是不支持重入锁的，但我们需要重入锁，怎么办呢？</h4><p>目前对于redis的重入锁业界还是有很多解决方案的，最流行的就是采用Redisson。</p>
<h2 id="Redisson可重入锁的例子"><a href="#Redisson可重入锁的例子" class="headerlink" title="Redisson可重入锁的例子"></a>Redisson可重入锁的例子</h2><h4 id="什么是-Redisson？"><a href="#什么是-Redisson？" class="headerlink" title="什么是 Redisson？"></a>什么是 Redisson？</h4><p>Redisson是Redis官方推荐的Java版的Redis客户端。 它基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。 它在网络通信上是基于NIO的Netty框架，保证网络通信的高性能。 在分布式锁的功能上，它提供了一系列的分布式锁；如：可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等等。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson github地址</a></p>
</blockquote>
<h4 id="Redisson的分布锁如何使用"><a href="#Redisson的分布锁如何使用" class="headerlink" title="Redisson的分布锁如何使用"></a>Redisson的分布锁如何使用</h4><h6 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.15.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;  </span><br></pre></td></tr></table></figure>

<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.SingleServerConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">//锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//Redisson需要的配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">node</span> <span class="operator">=</span> <span class="string">&quot;8.144.162.164:6376&quot;</span>;<span class="comment">//redis地址</span></span><br><span class="line">        node = node.startsWith(<span class="string">&quot;redis://&quot;</span>) ? node : <span class="string">&quot;redis://&quot;</span> + node;</span><br><span class="line">        <span class="type">SingleServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> config.useSingleServer()</span><br><span class="line">                .setAddress(node)</span><br><span class="line">                .setTimeout(<span class="number">5000</span>)<span class="comment">//超时时间</span></span><br><span class="line">                .setConnectionPoolSize(<span class="number">10</span>)</span><br><span class="line">                .setConnectionMinimumIdleSize(<span class="number">10</span>);</span><br><span class="line">        serverConfig.setPassword(<span class="string">&quot;root&quot;</span>);<span class="comment">//设置redis密码</span></span><br><span class="line">        <span class="comment">// 创建RedissonClient客户端实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="comment">//创建redisson的分布式锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        lock = rLock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//进入递归第一件事：加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            log.info(<span class="string">&quot;--------lock()执行后，当前线程持有此锁的次数：&#123;&#125; 是否有线程持有:&#123;&#125;&quot;</span>,lock.getHoldCount(),lock.isLocked());</span><br><span class="line">            log.info(<span class="string">&quot;--------递归&#123;&#125;次--------&quot;</span>,n);</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.doSomething(++n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log.info(<span class="string">&quot;--------lock()执行后，当前线程持有此锁的次数：&#123;&#125; 是否有线程持有:&#123;&#125;&quot;</span>,lock.getHoldCount(),lock.isLocked());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;--------------start---------------&quot;</span>);</span><br><span class="line">        RedissonLockDemo reentrantLockDemo=<span class="keyword">new</span> <span class="title class_">RedissonLockDemo</span>();</span><br><span class="line">        reentrantLockDemo.doSomething(<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;执行完doSomething方法 是否还持有锁：&#123;&#125;&quot;</span>, RedissonLockDemo.lock.isLocked());</span><br><span class="line">        log.info(<span class="string">&quot;--------------end---------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------start---------------</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：1 是否有线程持有:true</span><br><span class="line">- --------递归1次--------</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：2 是否有线程持有:true</span><br><span class="line">- --------递归2次--------</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：3 是否有线程持有:true</span><br><span class="line">- --------递归3次--------</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：2 是否有线程持有:true</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：1 是否有线程持有:true</span><br><span class="line">- --------lock()执行后，当前线程持有此锁的次数：0 是否有线程持有:false</span><br><span class="line">- 执行完doSomething方法 是否还持有锁：false</span><br><span class="line">- --------------end---------------</span><br></pre></td></tr></table></figure>

<p>看控制台打印能清楚知道Redisson是支持可重入锁了。</p>
<h4 id="那么Redisson是如何实现的了？"><a href="#那么Redisson是如何实现的了？" class="headerlink" title="那么Redisson是如何实现的了？"></a>那么Redisson是如何实现的了？</h4><p>我们跟一下lock.lock()的代码，发现它最终调用的是org.redisson.RedissonLock#tryLockInnerAsync的方法,具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码可以看到，它是使用lua脚本来保证多个命令执行的原子性，使用了hash来实现了分布式锁<br>现在我们来看下lua脚本的加锁流程</p>
<h6 id="第一个if判断"><a href="#第一个if判断" class="headerlink" title="第一个if判断"></a><strong>第一个if判断</strong></h6><ul>
<li>3行：它是先判断了当前key是否存在，从EXISTS命令我们知道返回值是0说明key不存在，说明没有加锁</li>
<li>4行：hincrby命令是对 ARGV[2] &#x3D; 进程ID+系统ID 进行原子自增加1</li>
<li>5行：是对整个hash设置过期期间</li>
</ul>
<h6 id="下面来看第二个if判断"><a href="#下面来看第二个if判断" class="headerlink" title="下面来看第二个if判断"></a><strong>下面来看第二个if判断</strong></h6><ul>
<li>8行：判断field是否存在于hash中，如果存在返回1，返回1说明是当前进程+当前线程ID 之前已经获得到锁了</li>
<li>9行：hincrby命令是对 ARGV[2] &#x3D; 进程ID+系统ID 进行原子自增加1，说明重入次数加1了</li>
<li>10行：再对整个hash设置过期期间</li>
</ul>
<h5 id="上面的代码，用到的redis命令先梳理一下"><a href="#上面的代码，用到的redis命令先梳理一下" class="headerlink" title="上面的代码，用到的redis命令先梳理一下"></a>上面的代码，用到的redis命令先梳理一下</h5><ul>
<li><strong>exists</strong> 查询一个key是否存在</li>
</ul>
<blockquote>
<p>EXISTS key [key …]<br><strong>返回值</strong><br>如下的整数结果<br>1 如果key存在<br>0 如果key不存在</p>
</blockquote>
<ul>
<li><strong>hincrby</strong> ：将hash中指定域的值增加给定的数字</li>
<li><strong>pexpire</strong>：设置key的有效时间以毫秒为单位</li>
<li><strong>hexists</strong>：判断field是否存在于hash中</li>
<li><strong>pttl</strong>：获取key的有效毫秒数</li>
</ul>
<h6 id="看lua脚本传入的参数我们知道："><a href="#看lua脚本传入的参数我们知道：" class="headerlink" title="看lua脚本传入的参数我们知道："></a>看lua脚本传入的参数我们知道：</h6><ul>
<li>KEYS[1] &#x3D; key的值</li>
<li>ARGV[1]) &#x3D; 持有锁的时间</li>
<li>ARGV[2] &#x3D; getLockName(threadId) 下面id就算系统在启动的时候会全局生成的uuid 来作为当前进程的id，加上线程id就是getLockName(threadId)了，可以理解为：进程ID+系统ID &#x3D; ARGV[2]</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">getLockName</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">&quot;:&quot;</span> + threadId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h6 id="下图是redis可视化工具看到是如何在hash存储的结构"><a href="#下图是redis可视化工具看到是如何在hash存储的结构" class="headerlink" title="下图是redis可视化工具看到是如何在hash存储的结构"></a>下图是redis可视化工具看到是如何在hash存储的结构</h6><p><img src="/%E9%94%81/2333726-20210523232655820-588475643.png" alt="image"></p>
<blockquote>
<p>Redisson的整个加锁流程跟ReentrantLock的加锁逻辑基本相同</p>
</blockquote>
<h6 id="解锁代码位于-org-redisson-RedissonLock-unlockInnerAsync-如下："><a href="#解锁代码位于-org-redisson-RedissonLock-unlockInnerAsync-如下：" class="headerlink" title="解锁代码位于 org.redisson.RedissonLock#unlockInnerAsync,如下："></a>解锁代码位于 org.redisson.RedissonLock#unlockInnerAsync,如下：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot; +</span><br><span class="line">                    &quot;return nil;&quot; +</span><br><span class="line">                    &quot;end; &quot; +</span><br><span class="line">                    &quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot; +</span><br><span class="line">                    &quot;if (counter &gt; 0) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot; +</span><br><span class="line">                    &quot;return 0; &quot; +</span><br><span class="line">                    &quot;else &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return 1; &quot; +</span><br><span class="line">                    &quot;end; &quot; +</span><br><span class="line">                    &quot;return nil;&quot;,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看这个解锁的Lua脚本，流程跟Reentrantlock的解锁逻辑也基本相同</p>
</blockquote>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p>悲观锁和独占锁是一个意思，它假设一定会发生冲突，因此获取到锁之后会阻塞其他等待线程。这么做的好处是简单安全，但是挂起线程和恢复线程都需要转入内核态进行，这样做会带来很大的性能开销。悲观锁的代表是 synchronized。</p>
<p>然而在真实环境中，大部分时候都不会产生冲突。</p>
<p>悲观锁会造成很大的浪费。而乐观锁不一样，它假设不会产生冲突，先去尝试执行某项操作，失败了再进行其他处理（一般都是不断循环重试）。这种锁不会阻塞其他的线程，也不涉及上下文切换，性能开销小。代表实现是 CAS。</p>
<p>①. 悲观锁(synchronized关键字和Lock的实现类都是悲观锁)</p>
<p>悲观锁概念</p>
<p>认为自己在<strong>使用数据的时候一定有别的线程来修改数据</strong>,因此在获取数据的时候会先加锁,确保数据不会被别的线程修改</p>
<p>适合场景</p>
<p>适合写操作多的场景,先加锁可以保证写操作时数据正确(写操作包括增删改)、显式的锁定之后再操作同步资源</p>
<p>②. 乐观锁</p>
<p> 乐观锁概念</p>
<p>乐观锁认为自己在<strong>使用数据时不会有别的线程修改数据</strong>,所以不会添加锁,</p>
<p>只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</p>
<p>如果这个数据没有被更新,当前线程将自己修改的数据成功写入。</p>
<p>如果数据已经被其他线程更新,则根据不同的实现方式执行不同的操作。</p>
<p>适合场景</p>
<ol>
<li>适合读操作多的场景,不加锁的特点能够使其读操作的性能大幅度提升</li>
</ol>
<p>实现</p>
<p>乐观锁一般有两种实现方式(采用版本号机制、CAS算法实现)</p>
<p>乐观锁在Java中通过使用无锁编程来实现，最常采用的时CAS算法,Java原子类中的递增操作就通过CAS自旋实现的</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//悲观锁的调用方式</span><br><span class="line">public synchronized void m1()&#123;</span><br><span class="line">    //加锁后的业务逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//保证多个线程使用的是同一个lock对象的前提下</span><br><span class="line">ReetrantLock lock=new ReentrantLock();</span><br><span class="line">public void m2()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        //操作同步资源</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//乐观锁的调用方式</span><br><span class="line">//保证多个线程使用的是同一个AtomicInteger</span><br><span class="line">private  AtomicInteger atomicIntege=new AtomicInteger();</span><br><span class="line">atomicIntege.incrementAndGet();</span><br></pre></td></tr></table></figure>

<p>AtomicInteger    一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。</p>
<p>public final int get() &#x2F;&#x2F;获取当前的值<br>public final int getAndSet(int newValue)&#x2F;&#x2F;获取当前的值，并设置新的值<br>public final int getAndIncrement()&#x2F;&#x2F;获取当前的值，并自增<br>public final int getAndDecrement() &#x2F;&#x2F;获取当前的值，并自减<br>public final int getAndAdd(int delta) &#x2F;&#x2F;获取当前的值，并加上预期的值</p>
<p>AtomicInteger源码分析——基于CAS的乐观锁实现</p>
<ol>
<li><p>悲观锁与乐观锁<br> 我们都知道，cpu是时分复用的，也就是把cpu的时间片，分配给不同的thread&#x2F;process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。<br><br> 但是，由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。<br><br> 所以就有了乐观锁的概念，他的核心思路就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。在上面的例子中，某个线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。</p>
</li>
<li><p>java中CAS的实现<br>   CAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<pre><code> JDK1.5中引入了底层的支持，在int、long和对象的引用等类型上都公开了CAS的操作，并且JVM把它们编译为底层硬件提供的最有效的方法，在运行CAS的平台上，运行时把它们编译为相应的机器指令。在java.util.concurrent.atomic包下面的所有的原子变量类型中，比如AtomicInteger，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作。
   
   在CAS操作中，会出现ABA问题。就是如果V的值先由A变成B，再由B变成A，那么仍然认为是发生了变化，并需要重新执行算法中的步骤。有简单的解决方案：不是更新某个引用的值，而是更新两个值，包括一个引用和一个版本号，即使这个值由A变为B，然后为变为A，版本号也是不同的。AtomicStampedReference和AtomicMarkableReference支持在两个变量上执行原子的条件更新。AtomicStampedReference更新一个“对象-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题，AtomicMarkableReference将更新一个“对象引用-布尔值”的二元组。
</code></pre>
</li>
<li><p>AtomicInteger的实现。<br> AtomicInteger 是一个支持原子操作的 Integer 类，就是保证对AtomicInteger类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。</p>
</li>
</ol>
<p>  接下来通过源代码来看AtomicInteger具体是如何实现的原子操作。</p>
<p>首先看incrementAndGet() 方法，下面是具体的代码。</p>
<p>public final int incrementAndGet() {<br>        for (;;) {<br>            int current &#x3D; get();<br>            int next &#x3D; current + 1;<br>            if (compareAndSet(current, next))<br>                return next;<br>        }<br>    }</p>
<pre><code> 通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面，compareAndSet()方法的代码如下：
</code></pre>
<p>public final boolean compareAndSet(int expect, int update) {<br>        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);<br>    }</p>
<p>compareAndSet()方法调用的compareAndSwapInt()方法的声明如下，是一个native方法。</p>
<p>   publicfinal native boolean compareAndSwapInt(Object var1, long var2, int var4, intvar5);</p>
<p>   compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet所做的为调用 Sun 的 UnSafe 的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。</p>
<pre><code>     类似的，还有decrementAndGet()方法。它和incrementAndGet()的区别是将 value 减 1，赋值给next 变量。

     AtomicInteger中还有getAndIncrement() 和getAndDecrement() 方法，他们的实现原理和上面的两个方法完全相同，区别是返回值不同，前两个方法返回的是改变之后的值，即next。而这两个方法返回的是改变之前的值，即current。还有很多的其他方法，就不列举了。
</code></pre>
<p>————————————————<br>版权声明：本文为CSDN博主「bestStyle」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qfycc92/article/details/46489553">https://blog.csdn.net/qfycc92/article/details/46489553</a></p>
<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><h2 id="公平锁和非公平锁-1"><a href="#公平锁和非公平锁-1" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁是指各个线程在加锁前先检查有无排队的线程，按排队顺序去获得锁。</p>
<p> 非公平锁是指线程加锁前不考虑排队问题，直接尝试获取锁，获取不到再去队尾排队。值得注意的是，在 AQS 的实现中，一旦线程进入排队队列，即使是非公平锁，线程也得乖乖排队。</p>
<ul>
<li>①. 什么是公平锁和非公平锁</li>
</ul>
<p>公平锁：是指多个线程按照<strong>申请锁的顺序来获取锁</strong>类似排队打饭先来后到</p>
<p>非公平锁：是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象</p>
<p>注意：synchronized 和 ReentrantLock 默认是非公平锁</p>
<p>②. 排队抢票案例(公平出现锁饥饿)</p>
<p>锁饥饿:我们使用5个线程买100张票,使用ReentrantLock默认是非公平锁,获取到的结果可能都是A线程在出售这100张票,会导致B、C、D、E线程发生锁饥饿(使用公平锁会有什么问题)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Ticket &#123;</span><br><span class="line">    private int number = 50;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock(true); //默认用的是非公平锁，分配的平均一点，=--》公平一点</span><br><span class="line">    public void sale() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if(number &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;\t 卖出第: &quot;+(number--)+&quot;\t 还剩下: &quot;+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*Object objectLock = new Object();</span><br><span class="line"></span><br><span class="line">    public void sale()&#123;</span><br><span class="line">        synchronized (objectLock)</span><br><span class="line">        &#123;</span><br><span class="line">            if(number &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;\t 卖出第: &quot;+(number--)+&quot;\t 还剩下: &quot;+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;</span><br><span class="line">public class SaleTicketDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket = new Ticket();</span><br><span class="line">        new Thread(() -&gt; &#123; for (int i = 1; i &lt;=55; i++) ticket.sale(); &#125;,&quot;a&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123; for (int i = 1; i &lt;=55; i++) ticket.sale(); &#125;,&quot;b&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123; for (int i = 1; i &lt;=55; i++) ticket.sale(); &#125;,&quot;c&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123; for (int i = 1; i &lt;=55; i++) ticket.sale(); &#125;,&quot;d&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123; for (int i = 1; i &lt;=55; i++) ticket.sale(); &#125;,&quot;e&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>③. 源码解读(ReentrantLock默认是非公平锁)</p>
<ol>
<li><p>公平锁:排序排队公平锁,就是判断同步队列是否还有先驱节点的存在(我前面还有人吗?),如果没有先驱节点才能获锁</p>
</li>
<li><p>先占先得非公平锁,是不管这个事的,只要能抢获到同步状态就可以</p>
</li>
<li><p>ReentrantLock默认是非公平锁,公平锁要多一个方法,所以非公平锁的性能更好(aqs源码)</p>
</li>
</ol>
<p><img src="/%E9%94%81/a7f483a7fa6648de8cd19762421953c3.png" alt="微信图片_20220106185212.png"></p>
<p>面试题</p>
<p> <strong>恢复挂起的线程到真正锁的获取还是有时间差的,?为什么默认非公平？</strong></p>
<p>恢复挂起的线程到真正锁的获取还是有时间差的,从开发人员来看这个时间微乎其微,但是从CPU的角度来看,这个时间存在的还是很明显的,所以非公平锁能更充分的利用CPU的时间片,尽量减少CPU空闲状态时间</p>
<p>使用多线程很重要的考量点是线程切换的开销,当采用非公平锁时,当一个线程请求锁获取同步状态,然后释放同步状态,因为不需要考虑是否还有前驱节点,所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大了,所以就减少了线程的开销线程的开销</p>
<p><strong>什么时候用公平？什么时候用非公平？</strong></p>
<p>(如果为了更高的吞吐量,很显然非公平锁是比较合适的,因为节省很多线程切换时间,吞吐量自然就上去了。否则那就用公平锁,大家公平使用)</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://cardioid.gitee.io/2021/05/05/Java/%E9%94%81/%E9%94%81/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/05/11/Java/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            自定义异常处理
          
        </div>
      </a>
    
    
      <a href="/2021/04/21/Java/ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/ThreadLocal/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">ThreadLocal的使用</div>
      </a>
    
  </nav>

  
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2018-2024
        <i class="ri-heart-fill heart_icon"></i> WangYingGangBlogs
      </li>
    </ul>
    
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="WangYingGangBlogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/1.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/2.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1501139180&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>